{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _exportNames = {\n  getProviderStatusAsync: true,\n  enableNetworkProviderAsync: true,\n  getCurrentPositionAsync: true,\n  getLastKnownPositionAsync: true,\n  watchPositionAsync: true,\n  getHeadingAsync: true,\n  watchHeadingAsync: true,\n  geocodeAsync: true,\n  reverseGeocodeAsync: true,\n  getPermissionsAsync: true,\n  requestPermissionsAsync: true,\n  getForegroundPermissionsAsync: true,\n  requestForegroundPermissionsAsync: true,\n  useForegroundPermissions: true,\n  getBackgroundPermissionsAsync: true,\n  requestBackgroundPermissionsAsync: true,\n  useBackgroundPermissions: true,\n  hasServicesEnabledAsync: true,\n  isBackgroundLocationAvailableAsync: true,\n  startLocationUpdatesAsync: true,\n  stopLocationUpdatesAsync: true,\n  hasStartedLocationUpdatesAsync: true,\n  startGeofencingAsync: true,\n  stopGeofencingAsync: true,\n  hasStartedGeofencingAsync: true,\n  setGoogleApiKey: true,\n  PermissionStatus: true,\n  Accuracy: true,\n  ActivityType: true,\n  GeofencingEventType: true,\n  GeofencingRegionState: true,\n  EventEmitter: true,\n  _getCurrentWatchId: true,\n  installWebGeolocationPolyfill: true\n};\nObject.defineProperty(exports, \"Accuracy\", {\n  enumerable: true,\n  get: function get() {\n    return _Location.LocationAccuracy;\n  }\n});\nObject.defineProperty(exports, \"ActivityType\", {\n  enumerable: true,\n  get: function get() {\n    return _Location.LocationActivityType;\n  }\n});\nObject.defineProperty(exports, \"EventEmitter\", {\n  enumerable: true,\n  get: function get() {\n    return _LocationEventEmitter.LocationEventEmitter;\n  }\n});\nObject.defineProperty(exports, \"GeofencingEventType\", {\n  enumerable: true,\n  get: function get() {\n    return _Location.LocationGeofencingEventType;\n  }\n});\nObject.defineProperty(exports, \"GeofencingRegionState\", {\n  enumerable: true,\n  get: function get() {\n    return _Location.LocationGeofencingRegionState;\n  }\n});\nObject.defineProperty(exports, \"PermissionStatus\", {\n  enumerable: true,\n  get: function get() {\n    return _expoModulesCore.PermissionStatus;\n  }\n});\nObject.defineProperty(exports, \"_getCurrentWatchId\", {\n  enumerable: true,\n  get: function get() {\n    return _LocationSubscribers._getCurrentWatchId;\n  }\n});\nexports.enableNetworkProviderAsync = enableNetworkProviderAsync;\nexports.geocodeAsync = geocodeAsync;\nexports.getBackgroundPermissionsAsync = getBackgroundPermissionsAsync;\nexports.getCurrentPositionAsync = getCurrentPositionAsync;\nexports.getForegroundPermissionsAsync = getForegroundPermissionsAsync;\nexports.getHeadingAsync = getHeadingAsync;\nexports.getLastKnownPositionAsync = getLastKnownPositionAsync;\nexports.getPermissionsAsync = getPermissionsAsync;\nexports.getProviderStatusAsync = getProviderStatusAsync;\nexports.hasServicesEnabledAsync = hasServicesEnabledAsync;\nexports.hasStartedGeofencingAsync = hasStartedGeofencingAsync;\nexports.hasStartedLocationUpdatesAsync = hasStartedLocationUpdatesAsync;\nObject.defineProperty(exports, \"installWebGeolocationPolyfill\", {\n  enumerable: true,\n  get: function get() {\n    return _GeolocationPolyfill.installWebGeolocationPolyfill;\n  }\n});\nexports.isBackgroundLocationAvailableAsync = isBackgroundLocationAvailableAsync;\nexports.requestBackgroundPermissionsAsync = requestBackgroundPermissionsAsync;\nexports.requestForegroundPermissionsAsync = requestForegroundPermissionsAsync;\nexports.requestPermissionsAsync = requestPermissionsAsync;\nexports.reverseGeocodeAsync = reverseGeocodeAsync;\nexports.setGoogleApiKey = setGoogleApiKey;\nexports.startGeofencingAsync = startGeofencingAsync;\nexports.startLocationUpdatesAsync = startLocationUpdatesAsync;\nexports.stopGeofencingAsync = stopGeofencingAsync;\nexports.stopLocationUpdatesAsync = stopLocationUpdatesAsync;\nexports.useForegroundPermissions = exports.useBackgroundPermissions = void 0;\nexports.watchHeadingAsync = watchHeadingAsync;\nexports.watchPositionAsync = watchPositionAsync;\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\nvar _expoModulesCore = require(\"expo-modules-core\");\nvar _ExpoLocation = _interopRequireDefault(require(\"./ExpoLocation\"));\nvar _Location = require(\"./Location.types\");\nObject.keys(_Location).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _Location[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _Location[key];\n    }\n  });\n});\nvar _LocationEventEmitter = require(\"./LocationEventEmitter\");\nvar _LocationSubscribers = require(\"./LocationSubscribers\");\nvar _GeolocationPolyfill = require(\"./GeolocationPolyfill\");\nvar _getProviderStatusAsync, _enableNetworkProviderAsync, _getCurrentPositionAsync, _getLastKnownPositionAsync, _watchPositionAsync, _getHeadingAsync, _watchHeadingAsync, _geocodeAsync, _reverseGeocodeAsync, _getPermissionsAsync, _requestPermissionsAsync, _getForegroundPermissionsAsync, _requestForegroundPermissionsAsync, _getBackgroundPermissionsAsync, _requestBackgroundPermissionsAsync, _hasServicesEnabledAsync, _isBackgroundLocationAvailableAsync, _startLocationUpdatesAsync, _stopLocationUpdatesAsync, _hasStartedLocationUpdatesAsync, _startGeofencingAsync, _stopGeofencingAsync, _hasStartedGeofencingAsync;\nfunction setGoogleApiKey(_apiKey) {}\nfunction getProviderStatusAsync() {\n  return (_getProviderStatusAsync = _getProviderStatusAsync || (0, _asyncToGenerator2.default)(function* () {\n    return _ExpoLocation.default.getProviderStatusAsync();\n  })).apply(this, arguments);\n}\nfunction enableNetworkProviderAsync() {\n  return (_enableNetworkProviderAsync = _enableNetworkProviderAsync || (0, _asyncToGenerator2.default)(function* () {\n    if (_expoModulesCore.Platform.OS === 'android') {\n      return _ExpoLocation.default.enableNetworkProviderAsync();\n    }\n  })).apply(this, arguments);\n}\nfunction getCurrentPositionAsync() {\n  return (_getCurrentPositionAsync = _getCurrentPositionAsync || (0, _asyncToGenerator2.default)(function* () {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return _ExpoLocation.default.getCurrentPositionAsync(options);\n  })).apply(this, arguments);\n}\nfunction getLastKnownPositionAsync() {\n  return (_getLastKnownPositionAsync = _getLastKnownPositionAsync || (0, _asyncToGenerator2.default)(function* () {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return _ExpoLocation.default.getLastKnownPositionAsync(options);\n  })).apply(this, arguments);\n}\nfunction watchPositionAsync(_x, _x2) {\n  return (_watchPositionAsync = _watchPositionAsync || (0, _asyncToGenerator2.default)(function* (options, callback) {\n    var watchId = _LocationSubscribers.LocationSubscriber.registerCallback(callback);\n    yield _ExpoLocation.default.watchPositionImplAsync(watchId, options);\n    return {\n      remove: function remove() {\n        _LocationSubscribers.LocationSubscriber.unregisterCallback(watchId);\n      }\n    };\n  })).apply(this, arguments);\n}\nfunction getHeadingAsync() {\n  return (_getHeadingAsync = _getHeadingAsync || (0, _asyncToGenerator2.default)(function* () {\n    var _ref;\n    return new Promise(function (_x3) {\n      return (_ref = _ref || (0, _asyncToGenerator2.default)(function* (resolve) {\n        var tries = 0;\n        var subscription = yield watchHeadingAsync(function (heading) {\n          if (heading.accuracy > 1 || tries > 5) {\n            subscription.remove();\n            resolve(heading);\n          } else {\n            tries += 1;\n          }\n        });\n      })).apply(this, arguments);\n    });\n  })).apply(this, arguments);\n}\nfunction watchHeadingAsync(_x4) {\n  return (_watchHeadingAsync = _watchHeadingAsync || (0, _asyncToGenerator2.default)(function* (callback) {\n    var watchId = _LocationSubscribers.HeadingSubscriber.registerCallback(callback);\n    yield _ExpoLocation.default.watchDeviceHeading(watchId);\n    return {\n      remove: function remove() {\n        _LocationSubscribers.HeadingSubscriber.unregisterCallback(watchId);\n      }\n    };\n  })).apply(this, arguments);\n}\nfunction geocodeAsync(_x5, _x6) {\n  return (_geocodeAsync = _geocodeAsync || (0, _asyncToGenerator2.default)(function* (address, options) {\n    if (typeof address !== 'string') {\n      throw new TypeError(`Address to geocode must be a string. Got ${address} instead.`);\n    }\n    if (options != null && options.useGoogleMaps || _expoModulesCore.Platform.OS === 'web') {\n      if (__DEV__) {\n        console.warn('The Geocoding API has been removed in SDK 49, use Place Autocomplete service instead' + '(https://developers.google.com/maps/documentation/places/web-service/autocomplete)');\n      }\n      return [];\n    }\n    return yield _ExpoLocation.default.geocodeAsync(address);\n  })).apply(this, arguments);\n}\nfunction reverseGeocodeAsync(_x7, _x8) {\n  return (_reverseGeocodeAsync = _reverseGeocodeAsync || (0, _asyncToGenerator2.default)(function* (location, options) {\n    if (typeof location.latitude !== 'number' || typeof location.longitude !== 'number') {\n      throw new TypeError('Location to reverse-geocode must be an object with number properties `latitude` and `longitude`.');\n    }\n    if (options != null && options.useGoogleMaps || _expoModulesCore.Platform.OS === 'web') {\n      if (__DEV__) {\n        console.warn('The Geocoding API has been removed in SDK 49, use Place Autocomplete service instead' + '(https://developers.google.com/maps/documentation/places/web-service/autocomplete)');\n      }\n      return [];\n    }\n    return yield _ExpoLocation.default.reverseGeocodeAsync(location);\n  })).apply(this, arguments);\n}\nfunction getPermissionsAsync() {\n  return (_getPermissionsAsync = _getPermissionsAsync || (0, _asyncToGenerator2.default)(function* () {\n    console.warn(`\"getPermissionsAsync()\" is now deprecated. Please use \"getForegroundPermissionsAsync()\" or \"getBackgroundPermissionsAsync()\" instead.`);\n    return yield _ExpoLocation.default.getPermissionsAsync();\n  })).apply(this, arguments);\n}\nfunction requestPermissionsAsync() {\n  return (_requestPermissionsAsync = _requestPermissionsAsync || (0, _asyncToGenerator2.default)(function* () {\n    console.warn(`\"requestPermissionsAsync()\" is now deprecated. Please use \"requestForegroundPermissionsAsync()\" or \"requestBackgroundPermissionsAsync()\" instead.`);\n    return yield _ExpoLocation.default.requestPermissionsAsync();\n  })).apply(this, arguments);\n}\nfunction getForegroundPermissionsAsync() {\n  return (_getForegroundPermissionsAsync = _getForegroundPermissionsAsync || (0, _asyncToGenerator2.default)(function* () {\n    return yield _ExpoLocation.default.getForegroundPermissionsAsync();\n  })).apply(this, arguments);\n}\nfunction requestForegroundPermissionsAsync() {\n  return (_requestForegroundPermissionsAsync = _requestForegroundPermissionsAsync || (0, _asyncToGenerator2.default)(function* () {\n    return yield _ExpoLocation.default.requestForegroundPermissionsAsync();\n  })).apply(this, arguments);\n}\nvar useForegroundPermissions = (0, _expoModulesCore.createPermissionHook)({\n  getMethod: getForegroundPermissionsAsync,\n  requestMethod: requestForegroundPermissionsAsync\n});\nexports.useForegroundPermissions = useForegroundPermissions;\nfunction getBackgroundPermissionsAsync() {\n  return (_getBackgroundPermissionsAsync = _getBackgroundPermissionsAsync || (0, _asyncToGenerator2.default)(function* () {\n    return yield _ExpoLocation.default.getBackgroundPermissionsAsync();\n  })).apply(this, arguments);\n}\nfunction requestBackgroundPermissionsAsync() {\n  return (_requestBackgroundPermissionsAsync = _requestBackgroundPermissionsAsync || (0, _asyncToGenerator2.default)(function* () {\n    return yield _ExpoLocation.default.requestBackgroundPermissionsAsync();\n  })).apply(this, arguments);\n}\nvar useBackgroundPermissions = (0, _expoModulesCore.createPermissionHook)({\n  getMethod: getBackgroundPermissionsAsync,\n  requestMethod: requestBackgroundPermissionsAsync\n});\nexports.useBackgroundPermissions = useBackgroundPermissions;\nfunction hasServicesEnabledAsync() {\n  return (_hasServicesEnabledAsync = _hasServicesEnabledAsync || (0, _asyncToGenerator2.default)(function* () {\n    return yield _ExpoLocation.default.hasServicesEnabledAsync();\n  })).apply(this, arguments);\n}\nfunction _validateTaskName(taskName) {\n  if (!taskName || typeof taskName !== 'string') {\n    throw new Error(`\\`taskName\\` must be a non-empty string. Got ${taskName} instead.`);\n  }\n}\nfunction isBackgroundLocationAvailableAsync() {\n  return (_isBackgroundLocationAvailableAsync = _isBackgroundLocationAvailableAsync || (0, _asyncToGenerator2.default)(function* () {\n    var providerStatus = yield getProviderStatusAsync();\n    return providerStatus.backgroundModeEnabled;\n  })).apply(this, arguments);\n}\nfunction startLocationUpdatesAsync(_x9) {\n  return (_startLocationUpdatesAsync = _startLocationUpdatesAsync || (0, _asyncToGenerator2.default)(function* (taskName) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      accuracy: _Location.LocationAccuracy.Balanced\n    };\n    _validateTaskName(taskName);\n    yield _ExpoLocation.default.startLocationUpdatesAsync(taskName, options);\n  })).apply(this, arguments);\n}\nfunction stopLocationUpdatesAsync(_x10) {\n  return (_stopLocationUpdatesAsync = _stopLocationUpdatesAsync || (0, _asyncToGenerator2.default)(function* (taskName) {\n    _validateTaskName(taskName);\n    yield _ExpoLocation.default.stopLocationUpdatesAsync(taskName);\n  })).apply(this, arguments);\n}\nfunction hasStartedLocationUpdatesAsync(_x11) {\n  return (_hasStartedLocationUpdatesAsync = _hasStartedLocationUpdatesAsync || (0, _asyncToGenerator2.default)(function* (taskName) {\n    _validateTaskName(taskName);\n    return _ExpoLocation.default.hasStartedLocationUpdatesAsync(taskName);\n  })).apply(this, arguments);\n}\nfunction _validateRegions(regions) {\n  if (!regions || regions.length === 0) {\n    throw new Error('Regions array cannot be empty. Use `stopGeofencingAsync` if you want to stop geofencing all regions');\n  }\n  for (var region of regions) {\n    if (typeof region.latitude !== 'number') {\n      throw new TypeError(`Region's latitude must be a number. Got '${region.latitude}' instead.`);\n    }\n    if (typeof region.longitude !== 'number') {\n      throw new TypeError(`Region's longitude must be a number. Got '${region.longitude}' instead.`);\n    }\n    if (typeof region.radius !== 'number') {\n      throw new TypeError(`Region's radius must be a number. Got '${region.radius}' instead.`);\n    }\n  }\n}\nfunction startGeofencingAsync(_x12) {\n  return (_startGeofencingAsync = _startGeofencingAsync || (0, _asyncToGenerator2.default)(function* (taskName) {\n    var regions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    _validateTaskName(taskName);\n    _validateRegions(regions);\n    yield _ExpoLocation.default.startGeofencingAsync(taskName, {\n      regions: regions\n    });\n  })).apply(this, arguments);\n}\nfunction stopGeofencingAsync(_x13) {\n  return (_stopGeofencingAsync = _stopGeofencingAsync || (0, _asyncToGenerator2.default)(function* (taskName) {\n    _validateTaskName(taskName);\n    yield _ExpoLocation.default.stopGeofencingAsync(taskName);\n  })).apply(this, arguments);\n}\nfunction hasStartedGeofencingAsync(_x14) {\n  return (_hasStartedGeofencingAsync = _hasStartedGeofencingAsync || (0, _asyncToGenerator2.default)(function* (taskName) {\n    _validateTaskName(taskName);\n    return _ExpoLocation.default.hasStartedGeofencingAsync(taskName);\n  })).apply(this, arguments);\n}","map":{"version":3,"names":["_expoModulesCore","require","_ExpoLocation","_interopRequireDefault","_Location","Object","keys","forEach","key","prototype","hasOwnProperty","call","_exportNames","exports","defineProperty","enumerable","get","_LocationEventEmitter","_LocationSubscribers","_GeolocationPolyfill","_getProviderStatusAsync","_enableNetworkProviderAsync","_getCurrentPositionAsync","_getLastKnownPositionAsync","_watchPositionAsync","_getHeadingAsync","_watchHeadingAsync","_geocodeAsync","_reverseGeocodeAsync","_getPermissionsAsync","_requestPermissionsAsync","_getForegroundPermissionsAsync","_requestForegroundPermissionsAsync","_getBackgroundPermissionsAsync","_requestBackgroundPermissionsAsync","_hasServicesEnabledAsync","_isBackgroundLocationAvailableAsync","_startLocationUpdatesAsync","_stopLocationUpdatesAsync","_hasStartedLocationUpdatesAsync","_startGeofencingAsync","_stopGeofencingAsync","_hasStartedGeofencingAsync","setGoogleApiKey","_apiKey","getProviderStatusAsync","_asyncToGenerator2","default","ExpoLocation","apply","arguments","enableNetworkProviderAsync","Platform","OS","getCurrentPositionAsync","options","length","undefined","getLastKnownPositionAsync","watchPositionAsync","_x","_x2","callback","watchId","LocationSubscriber","registerCallback","watchPositionImplAsync","remove","unregisterCallback","getHeadingAsync","_ref","Promise","_x3","resolve","tries","subscription","watchHeadingAsync","heading","accuracy","_x4","HeadingSubscriber","watchDeviceHeading","geocodeAsync","_x5","_x6","address","TypeError","useGoogleMaps","__DEV__","console","warn","reverseGeocodeAsync","_x7","_x8","location","latitude","longitude","getPermissionsAsync","requestPermissionsAsync","getForegroundPermissionsAsync","requestForegroundPermissionsAsync","useForegroundPermissions","createPermissionHook","getMethod","requestMethod","getBackgroundPermissionsAsync","requestBackgroundPermissionsAsync","useBackgroundPermissions","hasServicesEnabledAsync","_validateTaskName","taskName","Error","isBackgroundLocationAvailableAsync","providerStatus","backgroundModeEnabled","startLocationUpdatesAsync","_x9","LocationAccuracy","Balanced","stopLocationUpdatesAsync","_x10","hasStartedLocationUpdatesAsync","_x11","_validateRegions","regions","region","radius","startGeofencingAsync","_x12","stopGeofencingAsync","_x13","hasStartedGeofencingAsync","_x14"],"sources":["D:\\vikash\\AgroIntelPro-RN-App\\node_modules\\expo-location\\src\\Location.ts"],"sourcesContent":["import {\n  PermissionStatus,\n  PermissionResponse,\n  PermissionHookOptions,\n  createPermissionHook,\n  Platform,\n} from 'expo-modules-core';\n\nimport ExpoLocation from './ExpoLocation';\nimport {\n  LocationAccuracy,\n  LocationCallback,\n  LocationGeocodedAddress,\n  LocationGeocodedLocation,\n  LocationHeadingCallback,\n  LocationHeadingObject,\n  LocationLastKnownOptions,\n  LocationObject,\n  LocationOptions,\n  LocationPermissionResponse,\n  LocationProviderStatus,\n  LocationRegion,\n  LocationSubscription,\n  LocationTaskOptions,\n  LocationActivityType,\n  LocationGeofencingEventType,\n  LocationGeofencingRegionState,\n  LocationGeocodingOptions,\n} from './Location.types';\nimport { LocationEventEmitter } from './LocationEventEmitter';\nimport { LocationSubscriber, HeadingSubscriber, _getCurrentWatchId } from './LocationSubscribers';\n\n// @needsAudit\n/**\n * @deprecated The Geocoding web api is no longer available from SDK 49 onwards. Use [Place Autocomplete](https://developers.google.com/maps/documentation/places/web-service/autocomplete) instead.\n * @param apiKey Google API key obtained from Google API Console. This API key must have `Geocoding API`\n * enabled, otherwise your geocoding requests will be denied.\n */\nfunction setGoogleApiKey(_apiKey: string) {}\n\n// @needsAudit\n/**\n * Check status of location providers.\n * @return A promise which fulfills with an object of type [LocationProviderStatus](#locationproviderstatus).\n */\nexport async function getProviderStatusAsync(): Promise<LocationProviderStatus> {\n  return ExpoLocation.getProviderStatusAsync();\n}\n\n// @needsAudit\n/**\n * Asks the user to turn on high accuracy location mode which enables network provider that uses\n * Google Play services to improve location accuracy and location-based services.\n * @return A promise resolving as soon as the user accepts the dialog. Rejects if denied.\n */\nexport async function enableNetworkProviderAsync(): Promise<void> {\n  // If network provider is disabled (user's location mode is set to \"Device only\"),\n  // Android's location provider may not give you any results. Use this method in order to ask the user\n  // to change the location mode to \"High accuracy\" which uses Google Play services and enables network provider.\n  // `getCurrentPositionAsync` and `watchPositionAsync` are doing it automatically anyway.\n\n  if (Platform.OS === 'android') {\n    return ExpoLocation.enableNetworkProviderAsync();\n  }\n}\n\n// @needsAudit\n/**\n * Requests for one-time delivery of the user's current location.\n * Depending on given `accuracy` option it may take some time to resolve,\n * especially when you're inside a building.\n * > __Note:__ Calling it causes the location manager to obtain a location fix which may take several\n * > seconds. Consider using [`Location.getLastKnownPositionAsync`](#locationgetlastknownpositionasyncoptions)\n * > if you expect to get a quick response and high accuracy is not required.\n * @param options\n * @return A promise which fulfills with an object of type [`LocationObject`](#locationobject).\n */\nexport async function getCurrentPositionAsync(\n  options: LocationOptions = {}\n): Promise<LocationObject> {\n  return ExpoLocation.getCurrentPositionAsync(options);\n}\n\n// @needsAudit\n/**\n * Gets the last known position of the device or `null` if it's not available or doesn't match given\n * requirements such as maximum age or required accuracy.\n * It's considered to be faster than `getCurrentPositionAsync` as it doesn't request for the current\n * location, but keep in mind the returned location may not be up-to-date.\n * @param options\n * @return A promise which fulfills with an object of type [LocationObject](#locationobject) or\n * `null` if it's not available or doesn't match given requirements such as maximum age or required\n * accuracy.\n */\nexport async function getLastKnownPositionAsync(\n  options: LocationLastKnownOptions = {}\n): Promise<LocationObject | null> {\n  return ExpoLocation.getLastKnownPositionAsync(options);\n}\n\n// @needsAudit\n/**\n * Subscribe to location updates from the device. Please note that updates will only occur while the\n * application is in the foreground. To get location updates while in background you'll need to use\n * [Location.startLocationUpdatesAsync](#locationstartlocationupdatesasynctaskname-options).\n * @param options\n * @param callback This function is called on each location update. It receives an object of type\n * [`LocationObject`](#locationobject) as the first argument.\n * @return A promise which fulfills with a [`LocationSubscription`](#locationsubscription) object.\n */\nexport async function watchPositionAsync(\n  options: LocationOptions,\n  callback: LocationCallback\n): Promise<LocationSubscription> {\n  const watchId = LocationSubscriber.registerCallback(callback);\n  await ExpoLocation.watchPositionImplAsync(watchId, options);\n\n  return {\n    remove() {\n      LocationSubscriber.unregisterCallback(watchId);\n    },\n  };\n}\n\n// @needsAudit\n/**\n * Gets the current heading information from the device. To simplify, it calls `watchHeadingAsync`\n * and waits for a couple of updates, and then returns the one that is accurate enough.\n * @return A promise which fulfills with an object of type [LocationHeadingObject](#locationheadingobject).\n */\nexport async function getHeadingAsync(): Promise<LocationHeadingObject> {\n  return new Promise(async (resolve) => {\n    let tries = 0;\n\n    const subscription = await watchHeadingAsync((heading) => {\n      if (heading.accuracy > 1 || tries > 5) {\n        subscription.remove();\n        resolve(heading);\n      } else {\n        tries += 1;\n      }\n    });\n  });\n}\n\n// @needsAudit\n/**\n * Subscribe to compass updates from the device.\n * @param callback This function is called on each compass update. It receives an object of type\n * [LocationHeadingObject](#locationheadingobject) as the first argument.\n * @return A promise which fulfills with a [`LocationSubscription`](#locationsubscription) object.\n */\nexport async function watchHeadingAsync(\n  callback: LocationHeadingCallback\n): Promise<LocationSubscription> {\n  const watchId = HeadingSubscriber.registerCallback(callback);\n  await ExpoLocation.watchDeviceHeading(watchId);\n\n  return {\n    remove() {\n      HeadingSubscriber.unregisterCallback(watchId);\n    },\n  };\n}\n\n// @needsAudit\n/**\n * Geocode an address string to latitude-longitude location.\n * > **Note**: Using the Geocoding web api is no longer supported. Use [Place Autocomplete](https://developers.google.com/maps/documentation/places/web-service/autocomplete) instead.\n *\n * > **Note**: Geocoding is resource consuming and has to be used reasonably. Creating too many\n * > requests at a time can result in an error, so they have to be managed properly.\n * > It's also discouraged to use geocoding while the app is in the background and its results won't\n * > be shown to the user immediately.\n *\n * > On Android, you must request a location permission (`Permissions.LOCATION`) from the user\n * > before geocoding can be used.\n * @param address A string representing address, eg. `\"Baker Street London\"`.\n * @param options\n * @return A promise which fulfills with an array (in most cases its size is 1) of [`LocationGeocodedLocation`](#locationgeocodedlocation) objects.\n */\nexport async function geocodeAsync(\n  address: string,\n  options?: LocationGeocodingOptions\n): Promise<LocationGeocodedLocation[]> {\n  if (typeof address !== 'string') {\n    throw new TypeError(`Address to geocode must be a string. Got ${address} instead.`);\n  }\n\n  if (options?.useGoogleMaps || Platform.OS === 'web') {\n    if (__DEV__) {\n      console.warn(\n        'The Geocoding API has been removed in SDK 49, use Place Autocomplete service instead' +\n          '(https://developers.google.com/maps/documentation/places/web-service/autocomplete)'\n      );\n    }\n    return [];\n  }\n\n  return await ExpoLocation.geocodeAsync(address);\n}\n\n// @needsAudit\n/**\n * Reverse geocode a location to postal address.\n * > **Note**: Using the Geocoding web api is no longer supported. Use [Place Autocomplete](https://developers.google.com/maps/documentation/places/web-service/autocomplete) instead.\n *\n * > **Note**: Geocoding is resource consuming and has to be used reasonably. Creating too many\n * > requests at a time can result in an error, so they have to be managed properly.\n * > It's also discouraged to use geocoding while the app is in the background and its results won't\n * > be shown to the user immediately.\n *\n * > On Android, you must request a location permission (`Permissions.LOCATION`) from the user\n * > before geocoding can be used.\n * @param location An object representing a location.\n * @param options\n * @return A promise which fulfills with an array (in most cases its size is 1) of [`LocationGeocodedAddress`](#locationgeocodedaddress) objects.\n */\nexport async function reverseGeocodeAsync(\n  location: Pick<LocationGeocodedLocation, 'latitude' | 'longitude'>,\n  options?: LocationGeocodingOptions\n): Promise<LocationGeocodedAddress[]> {\n  if (typeof location.latitude !== 'number' || typeof location.longitude !== 'number') {\n    throw new TypeError(\n      'Location to reverse-geocode must be an object with number properties `latitude` and `longitude`.'\n    );\n  }\n\n  if (options?.useGoogleMaps || Platform.OS === 'web') {\n    if (__DEV__) {\n      console.warn(\n        'The Geocoding API has been removed in SDK 49, use Place Autocomplete service instead' +\n          '(https://developers.google.com/maps/documentation/places/web-service/autocomplete)'\n      );\n    }\n    return [];\n  }\n\n  return await ExpoLocation.reverseGeocodeAsync(location);\n}\n\n// @needsAudit\n/**\n * Checks user's permissions for accessing location.\n * @return A promise that fulfills with an object of type [LocationPermissionResponse](#locationpermissionresponse).\n * @deprecated Use [`getForegroundPermissionsAsync`](#locationgetforegroundpermissionsasync) or [`getBackgroundPermissionsAsync`](#locationgetbackgroundpermissionsasync) instead.\n */\nexport async function getPermissionsAsync(): Promise<LocationPermissionResponse> {\n  console.warn(\n    `\"getPermissionsAsync()\" is now deprecated. Please use \"getForegroundPermissionsAsync()\" or \"getBackgroundPermissionsAsync()\" instead.`\n  );\n  return await ExpoLocation.getPermissionsAsync();\n}\n\n// @needsAudit\n/**\n * Asks the user to grant permissions for location.\n * @return A promise that fulfills with an object of type [LocationPermissionResponse](#locationpermissionresponse).\n * @deprecated Use [`requestForegroundPermissionsAsync`](#locationrequestforegroundpermissionsasync) or [`requestBackgroundPermissionsAsync`](#locationrequestbackgroundpermissionsasync) instead.\n */\nexport async function requestPermissionsAsync(): Promise<LocationPermissionResponse> {\n  console.warn(\n    `\"requestPermissionsAsync()\" is now deprecated. Please use \"requestForegroundPermissionsAsync()\" or \"requestBackgroundPermissionsAsync()\" instead.`\n  );\n\n  return await ExpoLocation.requestPermissionsAsync();\n}\n\n// @needsAudit\n/**\n * Checks user's permissions for accessing location while the app is in the foreground.\n * @return A promise that fulfills with an object of type [PermissionResponse](#permissionresponse).\n */\nexport async function getForegroundPermissionsAsync(): Promise<LocationPermissionResponse> {\n  return await ExpoLocation.getForegroundPermissionsAsync();\n}\n\n// @needsAudit\n/**\n * Asks the user to grant permissions for location while the app is in the foreground.\n * @return A promise that fulfills with an object of type [PermissionResponse](#permissionresponse).\n */\nexport async function requestForegroundPermissionsAsync(): Promise<LocationPermissionResponse> {\n  return await ExpoLocation.requestForegroundPermissionsAsync();\n}\n\n// @needsAudit\n/**\n * Check or request permissions for the foreground location.\n * This uses both `requestForegroundPermissionsAsync` and `getForegroundPermissionsAsync` to interact with the permissions.\n *\n * @example\n * ```ts\n * const [status, requestPermission] = Location.useForegroundPermissions();\n * ```\n */\nexport const useForegroundPermissions = createPermissionHook({\n  getMethod: getForegroundPermissionsAsync,\n  requestMethod: requestForegroundPermissionsAsync,\n});\n\n// @needsAudit\n/**\n * Checks user's permissions for accessing location while the app is in the background.\n * @return A promise that fulfills with an object of type [PermissionResponse](#permissionresponse).\n */\nexport async function getBackgroundPermissionsAsync(): Promise<PermissionResponse> {\n  return await ExpoLocation.getBackgroundPermissionsAsync();\n}\n\n// @needsAudit\n/**\n * Asks the user to grant permissions for location while the app is in the background.\n * On __Android 11 or higher__: this method will open the system settings page - before that happens\n * you should explain to the user why your application needs background location permission.\n * For example, you can use `Modal` component from `react-native` to do that.\n * > __Note__: Foreground permissions should be granted before asking for the background permissions\n * (your app can't obtain background permission without foreground permission).\n * @return A promise that fulfills with an object of type [PermissionResponse](#permissionresponse).\n */\nexport async function requestBackgroundPermissionsAsync(): Promise<PermissionResponse> {\n  return await ExpoLocation.requestBackgroundPermissionsAsync();\n}\n\n// @needsAudit\n/**\n * Check or request permissions for the background location.\n * This uses both `requestBackgroundPermissionsAsync` and `getBackgroundPermissionsAsync` to\n * interact with the permissions.\n *\n * @example\n * ```ts\n * const [status, requestPermission] = Location.useBackgroundPermissions();\n * ```\n */\nexport const useBackgroundPermissions = createPermissionHook({\n  getMethod: getBackgroundPermissionsAsync,\n  requestMethod: requestBackgroundPermissionsAsync,\n});\n\n// --- Location service\n\n// @needsAudit\n/**\n * Checks whether location services are enabled by the user.\n * @return A promise which fulfills to `true` if location services are enabled on the device,\n * or `false` if not.\n */\nexport async function hasServicesEnabledAsync(): Promise<boolean> {\n  return await ExpoLocation.hasServicesEnabledAsync();\n}\n\n// --- Background location updates\n\nfunction _validateTaskName(taskName: string) {\n  if (!taskName || typeof taskName !== 'string') {\n    throw new Error(`\\`taskName\\` must be a non-empty string. Got ${taskName} instead.`);\n  }\n}\n\n// @docsMissing\nexport async function isBackgroundLocationAvailableAsync(): Promise<boolean> {\n  const providerStatus = await getProviderStatusAsync();\n  return providerStatus.backgroundModeEnabled;\n}\n\n// @needsAudit\n/**\n * Registers for receiving location updates that can also come when the app is in the background.\n *\n * # Task parameters\n *\n * Background location task will be receiving following data:\n * - `locations` - An array of the new locations.\n *\n * ```ts\n * import * as TaskManager from 'expo-task-manager';\n *\n * TaskManager.defineTask(YOUR_TASK_NAME, ({ data: { locations }, error }) => {\n *  if (error) {\n *    // check `error.message` for more details.\n *    return;\n *  }\n *  console.log('Received new locations', locations);\n * });\n * ```\n *\n * @param taskName Name of the task receiving location updates.\n * @param options An object of options passed to the location manager.\n *\n * @return A promise resolving once the task with location updates is registered.\n */\nexport async function startLocationUpdatesAsync(\n  taskName: string,\n  options: LocationTaskOptions = { accuracy: LocationAccuracy.Balanced }\n): Promise<void> {\n  _validateTaskName(taskName);\n  await ExpoLocation.startLocationUpdatesAsync(taskName, options);\n}\n\n// @needsAudit\n/**\n * Stops geofencing for specified task.\n * @param taskName Name of the background location task to stop.\n * @return A promise resolving as soon as the task is unregistered.\n */\nexport async function stopLocationUpdatesAsync(taskName: string): Promise<void> {\n  _validateTaskName(taskName);\n  await ExpoLocation.stopLocationUpdatesAsync(taskName);\n}\n\n// @needsAudit\n/**\n * @param taskName Name of the location task to check.\n * @return A promise which fulfills with boolean value indicating whether the location task is\n * started or not.\n */\nexport async function hasStartedLocationUpdatesAsync(taskName: string): Promise<boolean> {\n  _validateTaskName(taskName);\n  return ExpoLocation.hasStartedLocationUpdatesAsync(taskName);\n}\n\n// --- Geofencing\n\nfunction _validateRegions(regions: LocationRegion[]) {\n  if (!regions || regions.length === 0) {\n    throw new Error(\n      'Regions array cannot be empty. Use `stopGeofencingAsync` if you want to stop geofencing all regions'\n    );\n  }\n  for (const region of regions) {\n    if (typeof region.latitude !== 'number') {\n      throw new TypeError(`Region's latitude must be a number. Got '${region.latitude}' instead.`);\n    }\n    if (typeof region.longitude !== 'number') {\n      throw new TypeError(\n        `Region's longitude must be a number. Got '${region.longitude}' instead.`\n      );\n    }\n    if (typeof region.radius !== 'number') {\n      throw new TypeError(`Region's radius must be a number. Got '${region.radius}' instead.`);\n    }\n  }\n}\n\n// @needsAudit\n/**\n * Starts geofencing for given regions. When the new event comes, the task with specified name will\n * be called with the region that the device enter to or exit from.\n * If you want to add or remove regions from already running geofencing task, you can just call\n * `startGeofencingAsync` again with the new array of regions.\n *\n * # Task parameters\n *\n * Geofencing task will be receiving following data:\n *  - `eventType` - Indicates the reason for calling the task, which can be triggered by entering or exiting the region.\n *    See [GeofencingEventType](#geofencingeventtype).\n *  - `region` - Object containing details about updated region. See [LocationRegion](#locationregion) for more details.\n *\n * @param taskName Name of the task that will be called when the device enters or exits from specified regions.\n * @param regions Array of region objects to be geofenced.\n *\n * @return A promise resolving as soon as the task is registered.\n *\n * @example\n * ```ts\n * import { GeofencingEventType } from 'expo-location';\n * import * as TaskManager from 'expo-task-manager';\n *\n *  TaskManager.defineTask(YOUR_TASK_NAME, ({ data: { eventType, region }, error }) => {\n *   if (error) {\n *     // check `error.message` for more details.\n *     return;\n *   }\n *   if (eventType === GeofencingEventType.Enter) {\n *     console.log(\"You've entered region:\", region);\n *   } else if (eventType === GeofencingEventType.Exit) {\n *     console.log(\"You've left region:\", region);\n *   }\n * });\n * ```\n */\nexport async function startGeofencingAsync(\n  taskName: string,\n  regions: LocationRegion[] = []\n): Promise<void> {\n  _validateTaskName(taskName);\n  _validateRegions(regions);\n  await ExpoLocation.startGeofencingAsync(taskName, { regions });\n}\n\n// @needsAudit\n/**\n * Stops geofencing for specified task. It unregisters the background task so the app will not be\n * receiving any updates, especially in the background.\n * @param taskName Name of the task to unregister.\n * @return A promise resolving as soon as the task is unregistered.\n */\nexport async function stopGeofencingAsync(taskName: string): Promise<void> {\n  _validateTaskName(taskName);\n  await ExpoLocation.stopGeofencingAsync(taskName);\n}\n\n// @needsAudit\n/**\n * @param taskName Name of the geofencing task to check.\n * @return A promise which fulfills with boolean value indicating whether the geofencing task is\n * started or not.\n */\nexport async function hasStartedGeofencingAsync(taskName: string): Promise<boolean> {\n  _validateTaskName(taskName);\n  return ExpoLocation.hasStartedGeofencingAsync(taskName);\n}\n\nexport { LocationEventEmitter as EventEmitter, _getCurrentWatchId };\n\nexport {\n  LocationAccuracy as Accuracy,\n  LocationActivityType as ActivityType,\n  LocationGeofencingEventType as GeofencingEventType,\n  LocationGeofencingRegionState as GeofencingRegionState,\n  PermissionStatus,\n  PermissionHookOptions,\n  setGoogleApiKey,\n};\n\nexport { installWebGeolocationPolyfill } from './GeolocationPolyfill';\nexport * from './Location.types';\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}